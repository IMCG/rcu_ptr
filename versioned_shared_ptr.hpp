#include <memory>
#include <atomic>

template <typename T>
class versioned_shared_ptr {

    std::shared_ptr<T> sp;

public:
    // template <typename Y>
    // versioned_shared_ptr(const std::shared_ptr<Y>& r) {}

    versioned_shared_ptr() = default;

    // Copy
    versioned_shared_ptr(const versioned_shared_ptr& rhs) {
        sp = std::atomic_load(&rhs.sp);
    }
    versioned_shared_ptr& operator=(const versioned_shared_ptr& rhs) {
        overwrite(rhs.sp);
        return *this;
    }

    // Move
    // Move operations are not generated by the compiler since we provide
    // the copy operations.
    // However syntax like
    //     auto p = versioned_shared_ptr<int>{};
    // should be supported, therefore delete the move operations explicitly
    // is not an option.
    //     versioned_shared_ptr(versioned_shared_ptr&&) = delete;
    //     versioned_shared_ptr& operator=(versioned_shared_ptr&&) = delete;

    ~versioned_shared_ptr() = default;

    std::shared_ptr<const T> read() const { return std::atomic_load(&sp); }

    // Overwrites the content of the wrapped shared_ptr.
    // We don't get any information about the intermediate updates/overwrites.
    // We can use it to reset the wrapped data to a new value independent from
    // the old value.
    // E.g. vector.clear()
    void overwrite(const std::shared_ptr<T>& r) {
        std::atomic_store(&sp, r);
    }

    // This version requires the client to do the copy with make_shared
    //template <typename R>
    //void update(R&& fun) {
        //std::shared_ptr<T> sp_l = std::atomic_load(&sp);
        //auto exchange_result = false;
        //while (!exchange_result) {
            //auto r = std::forward<R>(fun)(std::shared_ptr<const T>(sp_l));
            //exchange_result =
                //std::atomic_compare_exchange_strong(&sp, &sp_l, r);
        //}
    //}

    // Updates the content of the wrapped shared_ptr.
    // We do get information about the intermediate updates/overwrites.
    // We can use it to update the wrapped data to a new value dependent from
    // the old value.
    // E.g. vector.push_back()
    template <typename R>
    void update(R&& fun) {
        std::shared_ptr<T> sp_l = std::atomic_load(&sp);
        auto exchange_result = false;
        while (!exchange_result) {
            auto new_ = std::forward<R>(fun)(static_cast<const T&>(*sp_l));
            auto r = std::make_shared<T>(new_);
            exchange_result =
                std::atomic_compare_exchange_strong(&sp, &sp_l, r);
        }
    }

};
